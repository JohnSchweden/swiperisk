---
phase: 03-polish-performance
plan: 03
type: execute
wave: 2
depends_on:
  - 03-01
  - 03-02
files_modified:
  - index.html
  - App.tsx
autonomous: true
must_haves:
  truths:
    - Touch gestures run at 60fps without dropped frames
    - Lighthouse performance score is ≥ 90
    - will-change: transform is applied to swipeable card element
    - backface-visibility: hidden is applied for GPU acceleration
    - -webkit-font-smoothing: antialiased is applied for crisp text rendering
    - Passive event listeners are used where scroll-blocking is not needed
  artifacts:
    - path: index.html
      provides: Performance optimization CSS with will-change and GPU acceleration
      contains: "will-change: transform, opacity; backface-visibility: hidden"
    - path: App.tsx
      provides: Optimized touch event handlers with passive listeners
      pattern: "{ passive: true }" for touchstart/touchmove where appropriate
  key_links:
    - from: App.tsx touch handlers
      to: index.html CSS optimizations
      via: will-change applied to card element
      pattern: "cardRef.*will-change|swipe-exit.*will-change"
---

<objective>
Optimize touch gesture performance and achieve Lighthouse score ≥ 90 through hardware acceleration, CSS optimizations, and event listener improvements.

Purpose: Users experience buttery-smooth 60fps animations during swipe interactions, even on mid-range mobile devices. Performance optimizations ensure the game feels premium and responsive without jank or dropped frames.

Output: Updated index.html with performance CSS, updated App.tsx with optimized event listeners, Lighthouse audit report showing score ≥ 90.
</objective>

<execution_context>
@/Users/yevgenschweden/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/yevgenschweden/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-polish-performance/03-CONTEXT.md

Key locked decisions from CONTEXT.md:
- 60fps on mid-range mobile devices
- Lighthouse performance score ≥ 90
- Optimize: will-change, GPU acceleration, passive listeners

Current state from Phase 2:
- will-change already added to swipe-exit classes in 02-01 (verify current state)
- Touch event handlers exist in App.tsx (lines 100-200 range)
- CRT overlay effect in index.html (body::after) may impact performance

Requirements from REQUIREMENTS.md (PERF-01):
- will-change: transform on swipeable card
- backface-visibility: hidden for GPU acceleration
- -webkit-font-smoothing: antialiased for crisp text
- Passive event listeners where possible
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add performance CSS optimizations</name>
  <files>index.html</files>
  <action>
Add GPU acceleration and performance CSS to the swipeable card element. Look for existing swipe-related CSS classes (around lines 74-80 where .swipe-exit-left and .swipe-exit-right are defined from Phase 2).

1. **Add performance class for the active card:**
   Add after the swipe-exit keyframes (around line 100):
   ```css
   /* Performance Optimizations */
   .swipe-card {
       will-change: transform, opacity;
       backface-visibility: hidden;
       -webkit-backface-visibility: hidden;
       transform: translateZ(0); /* Force GPU layer creation */
   }
   ```

2. **Add font smoothing for crisp text:**
   Update the body style (around line 20) to include:
   ```css
   body {
       font-family: 'Space Grotesk', sans-serif;
       background-color: #0a0a0c;
       color: #e2e8f0;
       overflow-y: auto;
       overflow-x: hidden;
       -webkit-font-smoothing: antialiased;
       -moz-osx-font-smoothing: grayscale;
       text-rendering: optimizeLegibility;
   }
   ```

3. **Optimize CRT overlay (if it causes performance issues):**
   The CRT effect at body::after (lines 33-45) can be expensive. Add a media query to disable on mobile:
   ```css
   /* Disable CRT effect on mobile for performance */
   @media (max-width: 768px) {
       body::after {
           display: none;
       }
   }
   ```

4. **Verify existing will-change from Phase 2:**
   Check that .swipe-exit-left and .swipe-exit-right still have will-change: transform, opacity from 02-01 implementation. If missing, add it.
  </action>
  <verify>
    grep -n "will-change\|backface-visibility\|-webkit-font-smoothing\|text-rendering" index.html | head -20
  </verify>
  <done>
    CSS performance optimizations applied: will-change on swipe-card class, backface-visibility for GPU acceleration, font-smoothing for crisp text, mobile media query for CRT overlay
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply swipe-card class to game card in App.tsx</name>
  <files>App.tsx</files>
  <action>
Apply the swipe-card performance class to the actual swipeable card element in the game screen. Find the card render code in renderGame() method.

1. **Locate the card element:**
   Look for the card div that has the transform style based on swipeOffset. This is likely around lines 550-650 in the renderGame method.

2. **Add the swipe-card class:**
   Find the card div with ref={cardRef} and add "swipe-card" to its className:
   ```jsx
   <div
     ref={cardRef}
     className={`relative bg-[#0a0a0c] border-2 border-slate-700 rounded-lg p-4 md:p-6 cursor-grab active:cursor-grabbing select-none swipe-card ${
       cardExitDirection === 'LEFT' ? 'swipe-exit-left' : 
       cardExitDirection === 'RIGHT' ? 'swipe-exit-right' : ''
     }`}
     style={{
       transform: `translateX(${swipeOffset}px) rotate(${swipeOffset * 0.05}deg)`,
       transition: isDragging ? 'none' : 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)',
       zIndex: 10
     }}
   >
   ```

3. **Ensure transform uses translateZ(0) for GPU:**
   The transform style already includes translateX and rotate. The swipe-card class adds translateZ(0) which creates a composite layer.

4. **Verify card stack layer (if exists from Phase 2):**
   If there's a "next card" preview from Phase 2, it should NOT have will-change to avoid unnecessary GPU memory usage. Only the active swipeable card needs it.
  </action>
  <verify>
    grep -n "swipe-card\|cardRef" App.tsx | head -15
  </verify>
  <done>
    swipe-card class applied to the active swipeable card element via ref={cardRef}, next card (if exists) intentionally does not have performance class to save GPU memory
  </done>
</task>

<task type="auto">
  <name>Task 3: Optimize touch event listeners for passive handling</name>
  <files>App.tsx</files>
  <action>
Optimize touch event listeners to use passive mode where they don't need to prevent default scrolling behavior.

1. **Locate touch handlers:**
   Find the touch event handlers in App.tsx. Look for:
   - handleTouchStart (around lines 120-140)
   - handleTouchMove (around lines 140-170)
   - handleTouchEnd (around lines 170-200)

2. **Analyze each handler for passive eligibility:**
   - handleTouchStart: May need to prevent default to stop scrolling during swipe → NOT passive
   - handleTouchMove: Called frequently during swipe, shouldn't block scroll → PASSIVE (if not calling preventDefault)
   - handleTouchEnd: End of interaction, low frequency → Can remain active

3. **Update event listeners if they use addEventListener:**
   If the code uses addEventListener for touch events (rather than React onTouch* props), update to:
   ```javascript
   cardElement.addEventListener('touchmove', handleTouchMove, { passive: true });
   ```

4. **Check React onTouchMove usage:**
   If using React's onTouchMove prop, it defaults to non-passive. To make it passive, you may need to use a ref and addEventListener manually, OR use CSS touch-action to indicate scroll behavior:
   ```css
   .swipe-card {
       touch-action: pan-y; /* Allow vertical scroll, handle horizontal in JS */
   }
   ```

5. **Add touch-action CSS to index.html:**
   Add to the .swipe-card class in index.html:
   ```css
   .swipe-card {
       will-change: transform, opacity;
       backface-visibility: hidden;
       -webkit-backface-visibility: hidden;
       transform: translateZ(0);
       touch-action: pan-y; /* Let browser handle vertical scroll */
   }
   ```

   This allows the browser to scroll vertically without waiting for JavaScript, while the game handles horizontal swipes.
  </action>
  <verify>
    grep -n "touch-action\|passive\|onTouchStart\|onTouchMove\|onTouchEnd" App.tsx | head -20
  </verify>
  <done>
    Touch event optimization: touch-action: pan-y added to swipe-card CSS, allowing browser to handle vertical scroll passively while game handles horizontal swipes
  </done>
</task>

<task type="auto">
  <name>Task 4: Run Lighthouse performance audit</name>
  <files>package.json</files>
  <action>
Run a Lighthouse performance audit to verify the optimizations achieve score ≥ 90.

1. **Ensure build is up to date:**
   First build the project to get optimized assets:
   ```bash
   bun run build
   ```

2. **Check for Lighthouse CLI or use browser DevTools:**
   Option A - Use Lighthouse CLI if available:
   ```bash
   npm install -g lighthouse
   lighthouse http://localhost:3000 --preset=desktop --output=json --output-path=lighthouse-report.json
   ```

   Option B - Provide instructions for manual Lighthouse run in browser:
   - Start dev server: bun dev
   - Open Chrome DevTools → Lighthouse tab
   - Select "Performance" only, "Desktop" or "Mobile"
   - Click "Analyze page load"
   - Record the performance score

3. **Key metrics to verify:**
   - Performance score ≥ 90
   - First Contentful Paint < 1.8s
   - Largest Contentful Paint < 2.5s
   - Total Blocking Time < 200ms
   - Cumulative Layout Shift < 0.1

4. **Document the results:**
   Note the final score and any remaining issues. If score < 90, identify the specific issues:
   - Render-blocking resources?
   - Unused JavaScript?
   - Large DOM size?
   - Unoptimized images?
   - Slow server response?

5. **Address any issues found:**
   If issues are found that can be quickly fixed (e.g., removing unused imports, deferring non-critical resources), fix them. Document any larger issues that would require separate work.
  </action>
  <verify>
    echo "Lighthouse audit completed. Check for lighthouse-report.json or document manual test results."
    cat lighthouse-report.json 2>/dev/null | grep -o '"score":[0-9.]*' | head -1 || echo "No report file - manual verification needed"
  </verify>
  <done>
    Lighthouse performance audit completed, score documented, any addressable issues fixed
  </done>
</task>

</tasks>

<verification>
1. CSS contains will-change, backface-visibility, and touch-action optimizations
2. App.tsx applies swipe-card class to the active card element
3. Font smoothing applied for crisp text rendering
4. CRT overlay disabled on mobile via media query
5. Lighthouse performance score ≥ 90 (or documented path to achieve it)
6. No console errors related to touch events or performance
</verification>

<success_criteria>
- will-change: transform applied to swipeable card element
- backface-visibility: hidden for GPU acceleration
- -webkit-font-smoothing: antialiased for text rendering
- touch-action: pan-y for passive scroll handling
- CRT overlay disabled on mobile
- Lighthouse performance score ≥ 90
- Touch gestures maintain 60fps during swipe
</success_criteria>

<output>
After completion, create `.planning/phases/03-polish-performance/03-03-SUMMARY.md`
</output>
